#!/usr/bin/env ruby
require 'optparse'
require 'optparse/time'
require 'octokit'
require 'io/console'
require 'logger'


class Mygit
  force = 'False'
  #@@mygit_log = Logger.new('log_file.log','monthly')
  

  def self.parse(args)

  logpath = 'log_file.log'
  options ={
    :files => [],
    :repo_and_branch => [],
    :force => 'False',
    :reviewers => []

  }

  OptionParser.new do |parser|
    #Handling the -create Command

    parser.on('-c', '--create [github repository link] [branch]',Array, 'Clone a repository and branch') do |create|
      options[:repo_and_branch] += create  
      repo=self.get_repo_name
      self.create(options[:repo_and_branch])
    end

    #Handling the Check Status --status command

    parser.on('-s','--status', 'Check status of recent pull request and review request') do |status|
      self.status()
    end

    #Handling the Git Configuration 

    parser.on('--config', 'Configure git credentials') do
      self.config_exist?()
    end

    #Handling the Request Review Command --review
   
    parser.on('-r','--request reviewers', Array, 'Request review from collaborator(s)') do |reviewer|
      self.request(options[:reviewers])
    end

    #Handling the prepare command
   
    parser.on('-p', '--prepare [base_branch]', String , 'Rebase against base branch') do |base|
      options[:base]=base
        if ARGV.include?('-f')
          force = 'True'
        end
          self.prepare(base)
    end

    parser.on('-l', '--log [path]' , String, 'Enter the absolute or relative path to store your logfile (default is the root directory of the application') do |path|
      logpath = path + '/' + "log_file.log"
      File.open('.logpath.txt','w') {|log_path| log_path.write(logpath)}
      repo = self.get_repo_name
      Dir.chdir(repo)
      write_to_file('log.txt',logpath,repo)
      Dir.chdir('..')

    end

    #Handling the force command for push and Config

    parser.on('-f', '--force', 'Force options') do |force|
      force='True'
    end

  options[:files] += ARGV
  options[:repo_and_branch] += ARGV
  options[:reviewers] += ARGV
  if File.exist?('.logpath.txt')
    logpath=File.open('.logpath.txt','r'){ |file| file.read }

  else
    logpath = "log_file.log"
  end
  @@mygit_log = Logger.new(logpath, 'monthly')


  def self.config_exist?()
    @@mygit_log.debug("<MyGit> : Checking if Config Exists")
    repo = self.get_repo_name()
    Dir.chdir "#{repo}/.#{repo}"
    if File.file?('gitconfig.txt')
      @@mygit_log.debug("<MyGit> : <ConfigExist?> : The config file exists")
      Dir.chdir('../..')
      if ARGV.include?('-f')
        @@mygit_log.debug("<MyGit> : <ConfigExist?> : Forcefully creating a new config")
        self.config_git()
        return                        
      end
      puts "<MyGit> : Config Exists already \n use -f tag to force a new config"
      @@mygit_log.debug("<MyGit> : <ConfigExist?> : Config Already Exists!")
    else
      @@mygit_log.debug("<MyGit> : <ConfigExist?> : Calling the ConfigGit function to configure the user's git")
      Dir.chdir('../..')
      self.config_git()        
     end

  end


  def self.return_git_credentials()
    @@mygit_log.debug("<MyGit> <ReturnGitCredentials> : Checking if credentials are stored")
    repo=self.get_repo_name()
    Dir.chdir(repo)
    gitconfig_data = self.read_hidden(repo,"gitconfig.txt")
    gitconfig_data = gitconfig_data.split("\n")
    Dir.chdir('..')
    return gitconfig_data
  end


  def self.config_git()
    @@mygit_log.debug("<MyGit> <ConfigGit> : Asking for the user`s git credentials through console")
    print "Enter your GitHub username: "
    username = STDIN.gets.chomp
    print "Enter your GitHub Passowrd: "
    password = STDIN.noecho(&:gets).chomp
    puts "\n"
    gitconf = username+"\n"+password
    repo = self.get_repo_name()
    Dir.chdir(repo)
    @@mygit_log.debug("<MyGit> <ConfigGit> : Writing to gitconfig file")
    self.write_to_file("gitconfig.txt",gitconf,repo)
    @@mygit_log.debug("<MyGit> <ConfigGit> : Git credentials have been configured")
    puts "<MyGit> : Git Credentials have been successfully configured"
  end


  def self.octokit_init()
    @@mygit_log.debug("<MyGit> <octoKitInit>  : Initializing Octokit API for git")
    gitconfig = self.return_git_credentials()
    login = gitconfig[0]
    password = gitconfig[1]
    client = Octokit::Client.new(:login => login , :password => password)
    @@mygit_log.debug("<MyGit> <octoKitInit> : Successfully logged into Octokit")
    return client
  end


  def self.git_exist?
    @@mygit_log.debug("<MyGit> : <GitExist?> : Checking if the user has git installed")
    git_path = `which git`
    if git_path.length >  0
      @@mygit_log.debug("<MyGit> : <GitExist?> : Git exists")
      return true
    else
      @@mygit_log.debug("<MyGit> : <GitExist?> : Git isnt installed, requesting the user to install git")
      puts "<MyGit> : <Error> : git isn`t installed on your system, kindly install and run the app again!"
      puts "<MyGit> : <Info> : To install git on your system run the following commands"
      puts "<MyGit> : <Info> : On Ubuntu -    `sudo apt-get install git-core`"
      puts "<MyGit> : <Info> : On CentOS -    `sudo yum install git`"
      puts "<MyGit> : <Info> : On Fedora -    `sudo yum install git-core`"
      puts "<MyGit> : <Info> : On Arch Linux -    `sudo pacman -Sy git`"
      return false
    end      
  end     


  def self.check_if_git_conf_exist()
    if File.file?('.gitconf.txt')
      return true
    else 
      return false
    end
  end


  def self.get_repo_name
    @@mygit_log.debug("<MyGit> : <getreponame> : Asking for reponame")
    repo_name = File.open('repo.txt', 'r'){ |repofile| repofile.read}
    repo_name = repo_name.split('/')[1]
    return repo_name
  end


  def self.create(repo_and_branch)
    @@mygit_log.debug("<MyGit> <mygit_create> : mygit_create called with repo: #{repo_and_branch[1]} and branch: #{repo_and_branch[2]}")
    @@mygit_log.debug("<MyGit> <mygit_create> : Checking for git exists :")
    if !self.git_exist?()
      @@mygit_log.debug("<MyGit> <mygit_create> : Exiting because git doesn`t exist")
      exit
    end
    repo = repo_and_branch[1]
    branch =  repo_and_branch[2]
    @@mygit_log.debug("<MyGit> <mygit_create> : Starting to clone the repo #{repo}")
    system "git clone #{repo}"
    puts "<MyGit> : Successfully Cloned #{repo}"        
    @@mygit_log.debug("<MyGit> <mygit_create> : Successfully cloned #{repo}")
        
    #Get the last modified folder (which will be the cloned repo) so that
    #we can cd into it
       
    lastmod = self.get_last_modified()
    @@mygit_log.debug("<MyGit> <mygit_create> : last modified directory : #{lastmod}")
       
    #cd into it
       
    pw = `pwd`
    pw=pw.chomp                                    
    Dir.chdir "#{lastmod}"
    username = repo.split('/')[3]
    repo=(repo.split('/')[4]).split('.')[0]
    puts repo
    repo_link  = "#{username}"+"/"+"#{lastmod}"
    Dir.mkdir(lastmod)
    `mv #{lastmod} .#{lastmod}`
    @@mygit_log.debug("<MyGit> <mygit_create> : Created the Hidden Directory to store data")
    system "git init"
    system "git pull"

    if !(branch==repo)
      system "git branch #{branch}"
      system "git checkout #{branch}"
      self.write_to_file("Direx.txt",branch,repo)
      repodirex= "#{pw}"+"/repo.txt"
      @@mygit_log.debug("<MyGit> <mygit_create> : Writing #{repo_link} to the files")
      self.write_to_file(repodirex,repo_link,repo)
      self.write_to_file("repo.txt",repo_link,repo)                                                           
      puts "<MyGit> : Successfully created branch :  #{branch}"
      @@mygit_log.debug("<MyGit> <mygit_create> : Successfully executed the create command!")
    end


  end
  def self.write_to_file(fname,content,repo)
    Dir.chdir ".#{repo}" do
    File.open(fname, 'w') {|file| file.write(content)}
    @@mygit_log.debug("<MyGit> <writetofile> : Successfully wrote #{content} to #{fname}")
      end
  end

  def self.get_last_modified()
    @@mygit_log.debug("<MyGit> <getlastmodified> : getting the last modified file")
    lastmod= `ls -td -- */ | head -n 1 | cut -d'/' -f1`
    lastmod =lastmod.chomp
    return lastmod
  end

  def self.base_exist?(repo)
    Dir.chdir "#{repo}/.#{repo}"
    if File.file?('Base.txt')
      @@mygit_log.debug("<MyGit> <Base?> : Base File exists")
      base_branch = File.open('Base.txt') { |basefile| basefile.read }
    end
      Dir.chdir "../.."
      if base_branch.nil?
        @@mygit_log.debug("<MyGit> <Base?> : Base file is empty")
        return false
      else
        @@mygit_log.debug("<MyGit> <Base?> : Base branch is #{base_branch}")
        return true
      end
  end


  def self.read_hidden(repo,file)
    Dir.chdir ".#{repo}"
    if !File.exist?(file)
      @@mygit_log.debug("<MyGit> <readhidden> : #{file} doesn't exist")
      puts " <MyGit> : Error : File #{file} doesn`t exist"
      exit
    end
      data = File.open(file, 'r').read
      Dir.chdir ".."
      @@mygit_log.debug("Read data #{data} from #{file}")
      return data
  end


  def self.prepare(base)      
    repo = self.get_repo_name()
    if base.nil? and !(self.base_exist?(repo))
      @@mygit_log.debug("<MyGit> <mygit_prepare> : Base Branch is not specified")
      puts "Base branch not specified!"
      exit
    end
    Dir.chdir(repo)
    if base.nil?
      @@mygit_log.debug("<MyGit> <mygit_prepare> : Reading base from file as it is not provided in function parameter")
      base = self.read_hidden(repo, "Base.txt")
    end
    self.write_to_file("Base.txt",base,repo)    
    @@mygit_log.debug("<MyGit> <mygit_prepare> : Calling rebase")
    system "git rebase #{base}"
    @@mygit_log.debug("<MyGit> <mygit_prepare> : Rebase ended")
    directory = self.read_hidden(repo,"Direx.txt")
    if force == 'True'
      system "git push -f -u origin #{directory}"
    else
      system "git push -u origin #{directory}"
    end
    @@mygit_log.debug("<MyGit> <mygit_prepare> : git pushed #{directory}")
  end

  def self.request(reviewers)
    @@mygit_log.debug("Request Called")
    @@mygit_log.debug("<MYGIT> <mygit_request>module : Check if git exists? : #{self.git_exist?()}")
    reviewers.shift
    repo_directory = File.open("repo.txt")
    repo_directory = repo_directory.read
    repo = self.get_repo_name()    
    Dir.chdir(repo)    
    base_branch = self.read_hidden(repo,"Base.txt")       
    working_branch = self.read_hidden(repo,"Direx.txt") 
    Dir.chdir('..')
	  @@mygit_log.debug("<MyGit> <mygit_request> : Initializing the octokit client")
    client = self.octokit_init()
    @@mygit_log.debug("<MyGit> <mygit_request> : Successfully initialized the octokit client")
    @@mygit_log.debug("<MyGit> <mygit_request> : Now creating a pull_request for #{repo_directory} from #{working_branch} to #{base_branch}")
    create_pull = client.create_pull_request(repo_directory,base_branch, working_branch , "From Girish's App", "Pull Request body")
    @@mygit_log.debug("<MyGit> <mygit_request> : Successfully created the pull requested with pull request number #{create_pull.number}")
    reqreview=client.request_pull_request_review(repo_directory, create_pull.number , reviewers: reviewers)        
    @@mygit_log.debug("<MyGit> <mygit_request> : requesting a review")
    reviewers.each do |reviewer|        
      puts "<MyGit> : Review requested by #{reviewer}"
		  @@mygit_log.debug("<MyGit> <mygit_request> : requested review by #{reviewer}")
    end

	  @@mygit_log.debug("<MyGit> <mygit_request> : Requesting a comparison between #{base_branch} and #{working_branch}")
    comparison_branches = client.compare(repo_directory, base_branch ,working_branch , options = {})
	
    @@mygit_log.debug("<MyGit> <mygit_request> : Successfully requested the comparison")
    comparison_json = Hash.new
	
	  @@mygit_log.debug("<MyGit> <mygit_request> : creating a JSON object for the return value of comparison")
    counter=0
    comparison_branches.files.each do |file|
      array_files=[]  

      file.each do |f|
        array_files.push(f)
      end
      comparison_json[counter] = array_files
      counter=counter+1
    end
    File.open("comparison_result.json","w") do |f|
      f.write(comparison_json.to_json)
    end
	  @@mygit_log.debug("<MyGit> <mygit_request> : Saved the json object on disk")

    self.write_to_file("pullreq.txt", create_pull.number, repo)
    self.write_to_file("reviewreq.txt", reqreview.id , repo)                        
  	
	  @@mygit_log.debug("<MyGit> <mygit_status> Writing Pull number and review ID to files successfully")
                                
  end

  def self.status() 
	  @@mygit_log.debug("<MyGit> <mygit_status> : Entered the mygit_status module")
	  @@mygit_log.debug("<MyGit> <mygit_status> : Initializing the octokit API")
    client = self.octokit_init()  
	  @@mygit_log.debug("<MyGit> <mygit_status> : Successfully initialized the octokit API")
    repo = self.get_repo_name()
	  @@mygit_log.debug("<MyGit> <mygit_status> : Requested the Repo Name")
    repo_directory = File.open("repo.txt").read
    Dir.chdir(repo)
	  @@mygit_log.debug("<MyGit> <mygit_status> : Reading hidden files to get pull request number, review request id and base branch")
    pullreq=self.read_hidden(repo,"pullreq.txt")
    reviewreq = self.read_hidden(repo,"reviewreq.txt")
    base = self.read_hidden(repo,"Base.txt")	
    review_status=client.pull_request_reviews(repo_directory, pullreq)
	  @@mygit_log.debug("<MyGit> <mygit_status> : Requesting the status of the review")  
    if review_status.empty?
      puts "<MyGit> : Review not done yet"
		  @@mygit_log.debug("<MyGit> <mygit_status> : Review not done yet")
      exit 
    else
      review_ix= review_status.length - 1         
      status=client.pull_request_review(repo_directory, pullreq, review_status[review_ix].id)
      @@mygit_log.debug("<MyGit> : <mygit_status> : Requesting the state of the review")                                             
      puts status.state
    end
            
    if status.state == 'APPROVED' 
      puts "<MyGit> : your review is approved"
	  	@@mygit_log.debug("<MyGit> <mygit_status> : Review is approved! ")
      system "git add ."
      system "git commit -m 'from Girish's App'"
      system "git merge --squash #{base}"
		  @@mygit_log.debug("<MyGit> <mygit_status> : squashed and mered to #{base}")

    end

  end



  end.parse!
  end
end 




initial = Mygit.parse(ARGV)
